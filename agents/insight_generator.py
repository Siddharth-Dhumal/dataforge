# In this file, based on the graphs and data generated, we need to drae 5 key points of interest of important aspects of the numbers and data. 

"""
Insight Generator Agent  —  Agent 3
====================================
Accepts one or more chart specs (dicts parsed from JSON) and returns 5 KPI
insight strings generated by Claude via the Anthropic tool-use pattern.

Design constraints
------------------

* 8-second hard timeout via threading.Timer.  On timeout the caller receives a
  sentinel dict so the UI can show "Insights loading…" + a refresh button.
* Only summary statistics (column, min, max, mean, count) are ever sent to
  Claude.  Raw rows / PII never leave this module.
* Never called on a failed query — the caller must gate on query success.

Public API
----------
generate_insights(chart_specs: list[dict]) -> dict
    chart_specs : list of one or more chart spec dicts, each containing at
                  minimum a "data" key whose value is a list-of-dicts (rows).
    Returns:
        {
            "success":   bool,
            "timed_out": bool,
            "error":     str | None,
            "kpis":      list[str]   # exactly 5 strings, or [] on failure
        }
"""

from __future__ import annotations

import os
import threading
from typing import Any

import anthropic

# ── Constants ────────────────────────────────────────────────────────────────

TIMEOUT_SECONDS = 8
MODEL = "claude-opus-4-6"

# Tool schema — Claude must call this tool to return its answer.
_TOOLS: list[dict] = [
    {
        "name": "generate_insight",
        "description": (
            "Return exactly 5 KPI insight strings derived from the chart data "
            "summary provided.  Each insight must be a self-contained, plain-"
            "English sentence that highlights a key pattern, trend, or anomaly."
        ),
        "input_schema": {
            "type": "object",
            "properties": {
                "kpis": {
                    "type": "array",
                    "items": {"type": "string"},
                    "minItems": 5,
                    "maxItems": 5,
                    "description": (
                        "Exactly 5 KPI insight strings. Each string is a "
                        "2-3 sentence plain-English interpretation of a key "
                        "pattern in the data."
                    ),
                },
                "has_insight": {
                    "type": "boolean",
                    "description": (
                        "False only when the data contains no meaningful "
                        "pattern (e.g. all identical values, all nulls)."
                    ),
                },
            },
            "required": ["kpis", "has_insight"],
        },
    }
]

_SYSTEM_PROMPT = (
    "You are a senior data analyst composing an AI Briefing card for a "
    "business dashboard.  You will receive summary statistics (column name, "
    "min, max, mean, count) for one or more charts.  Your task is to call the "
    "`generate_insight` tool with exactly 5 KPI insights that a non-technical "
    "executive would find actionable.  Focus on trends, outliers, comparisons, "
    "and anomalies visible in the numbers.  Never invent data not present in "
    "the summary.  Keep each insight to 2-3 sentences."
)

# ── Internal helpers ──────────────────────────────────────────────────────────


def _summarise_chart(chart_spec: dict, chart_index: int) -> str:
    """
    Converts a single chart spec into a compact summary-stats block.
    Only numeric columns are summarised; string columns are listed by name.

    Args:
        chart_spec: A dict that must contain either a "data" key (list of row
                    dicts) or a "summary" key (pre-computed stats dict).
        chart_index: 1-based chart number used for labelling.

    Returns:
        A multi-line string safe to embed in the LLM prompt.
    """
    lines: list[str] = [f"=== Chart {chart_index} ==="]

    # Accept a pre-computed summary dict for callers that already aggregated.
    if "summary" in chart_spec and isinstance(chart_spec["summary"], dict):
        for col, stats in chart_spec["summary"].items():
            lines.append(f"  {col}: {stats}")
        return "\n".join(lines)

    rows: list[dict] = chart_spec.get("data", [])
    if not rows:
        lines.append("  (no data)")
        return "\n".join(lines)

    # Derive column names from the first row.
    col_names: list[str] = list(rows[0].keys()) if rows else []
    numeric_stats: dict[str, dict[str, Any]] = {}
    string_cols: list[str] = []

    for col in col_names:
        values = [row[col] for row in rows if col in row and row[col] is not None]
        numeric_values = []
        for v in values:
            try:
                numeric_values.append(float(v))
            except (TypeError, ValueError):
                pass

        if numeric_values:
            numeric_stats[col] = {
                "count": len(numeric_values),
                "min": round(min(numeric_values), 4),
                "max": round(max(numeric_values), 4),
                "mean": round(sum(numeric_values) / len(numeric_values), 4),
            }
        else:
            string_cols.append(col)

    # Chart-level metadata (title, axis labels) if present — no row data.
    for meta_key in ("title", "x", "y", "color", "chart_type", "type"):
        if meta_key in chart_spec:
            lines.append(f"  {meta_key}: {chart_spec[meta_key]}")

    lines.append(f"  row_count: {len(rows)}")

    for col, stats in numeric_stats.items():
        lines.append(
            f"  {col} — count={stats['count']}, "
            f"min={stats['min']}, max={stats['max']}, mean={stats['mean']}"
        )

    if string_cols:
        lines.append(f"  categorical columns: {', '.join(string_cols)}")

    return "\n".join(lines)


def _build_user_prompt(chart_specs: list[dict]) -> str:
    """Assembles all chart summaries into a single user message."""
    blocks = [
        _summarise_chart(spec, i + 1) for i, spec in enumerate(chart_specs)
    ]
    header = (
        f"Here are summary statistics for {len(chart_specs)} chart(s).  "
        "Call the `generate_insight` tool with exactly 5 KPI insights.\n\n"
    )
    return header + "\n\n".join(blocks)


def _call_claude_with_tools(user_prompt: str) -> dict:
    """
    Calls Claude using the tool-use API and extracts the `generate_insight`
    tool call from the response.

    Returns a result dict with keys: success, kpis, has_insight, error.
    """
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    client = anthropic.Anthropic(api_key=api_key)

    try:
        response = client.messages.create(
            model=MODEL,
            max_tokens=1024,
            temperature=0.3,
            system=_SYSTEM_PROMPT,
            tools=_TOOLS,
            tool_choice={"type": "any"},   # Force a tool call every time.
            messages=[{"role": "user", "content": user_prompt}],
        )
    except Exception as exc:
        return {
            "success": False,
            "kpis": [],
            "has_insight": False,
            "error": f"Claude API Error: {exc}",
        }

    # Extract the tool_use block from the response content.
    tool_input: dict | None = None
    for block in response.content:
        if block.type == "tool_use" and block.name == "generate_insight":
            tool_input = block.input
            break

    if tool_input is None:
        # Claude spoke instead of calling the tool — shouldn't happen with
        # tool_choice="any", but handle gracefully.
        return {
            "success": False,
            "kpis": [],
            "has_insight": False,
            "error": "Claude did not call the generate_insight tool.",
        }

    kpis: list[str] = tool_input.get("kpis", [])
    has_insight: bool = tool_input.get("has_insight", True)

    return {
        "success": True,
        "kpis": kpis[:5],       # Enforce max-5 even if Claude over-generates.
        "has_insight": has_insight,
        "error": None,
    }


# ── Public API ────────────────────────────────────────────────────────────────


def generate_insights(chart_specs: list[dict]) -> dict:
    """
    Main entry point for the Insight Generator Agent.

    Parameters
    ----------
    chart_specs : list[dict]
        One or more chart spec dicts.  Each must contain a "data" key (list of
        row dicts) OR a pre-computed "summary" key.  Optional metadata keys
        ("title", "x", "y", "type") are included in the prompt for context.

    Returns
    -------
    dict with keys:
        success   (bool)       — True if Claude returned valid insights.
        timed_out (bool)       — True if the 8-second limit was exceeded.
        error     (str | None) — Human-readable error message, or None.
        kpis      (list[str])  — Exactly 5 KPI strings, or [] on failure.

    Notes
    -----
    * This function BLOCKS for at most TIMEOUT_SECONDS seconds.
    * It is safe to call from the Streamlit main thread.
    * It must only be called after a successful query — never on error states.
    """
    if not chart_specs:
        return {
            "success": False,
            "timed_out": False,
            "error": "No chart specs provided.",
            "kpis": [],
        }

    user_prompt = _build_user_prompt(chart_specs)

    # ── Thread + Timer for the 8-second hard timeout ──────────────────────
    result_container: dict = {}
    exception_container: dict = {}

    def _worker() -> None:
        try:
            result_container.update(_call_claude_with_tools(user_prompt))
        except Exception as exc:  # noqa: BLE001
            exception_container["error"] = str(exc)

    thread = threading.Thread(target=_worker, daemon=True)
    thread.start()
    thread.join(timeout=TIMEOUT_SECONDS)

    if thread.is_alive():
        # Thread is still running — we timed out.
        return {
            "success": False,
            "timed_out": True,
            "error": "Insight generation timed out after 8 seconds.",
            "kpis": [],
        }

    if exception_container:
        return {
            "success": False,
            "timed_out": False,
            "error": exception_container["error"],
            "kpis": [],
        }

    # Merge standard fields into return dict.
    return {
        "success": result_container.get("success", False),
        "timed_out": False,
        "error": result_container.get("error"),
        "kpis": result_container.get("kpis", []),
    }
